clc
clearvars
close all
addpath(genpath('../../MATLAB'))

% Physics of a OMNIX boat (Robocat) DLC 2022

% load in the parameters for a frame, generated by rover.m
try
    state = load('robocat.mat','rover');
catch
    run('Boat_omnix.m')
    fprintf('Could not find rovercat.mat file, running Boat_omnix.m\n')
    return
end

% Setup environmental conditions
state.current_u = 0;%2.5;
state.current_v = 1;


state.environment.density = 1.225; % air (kg/m^3)
% state.environment.density = 1000.1; % water (kg/m^3)
state.gravity_mss = 9.80665; % (m/s^2)
state.totaltime = 0;

% Setup the time step size for the Physics model
max_timestep = 1/50;

% define init and time setup functions
init_function = @init;
physics_function = @physics_step;

% setup connection
SITL_connector(state,init_function,physics_function,max_timestep);

% Simulator model must take and return a structure with the felids:
% gyro(roll, pitch, yaw) (radians/sec) body frame
% attitude(roll, pitch yaw) (radians)
% accel(north, east, down) (m/s^2) body frame
% velocity(north, east,down) (m/s) earth frame
% position(north, east, down) (m) earth frame
% the structure can have any other felids required for the physics model

% init values
function state = init(state)
    for i = 1:numel(state.rover.motors)
        state.rover.motors(i).rpm = 0;
        state.rover.motors(i).current = 0;
    end
    state.gyro      = [0;0;0]; % (rad/sec)
    state.dcm       = diag([1,1,1]); % direction cosine matrix
    state.attitude  = [0;0;0]; % (radians) (roll, pitch, yaw)
    state.accel     = [0;0;0]; % (m/s^2) body frame
    state.velocity  = [0;0;0]; % (m/s) earth frame
    state.position  = [0;0;0]; % (m) earth frame
    state.bf_velo   = [0;0;0]; % (m/s) body frame
end

% Take a physics time step
function state = physics_step(pwm_in,state)
    
    % Calculate the dropped battery voltage, assume current draw from last step
    state.rover.battery.current = sum([state.rover.motors.current]);
    state.rover.battery.dropped_voltage = state.rover.battery.voltage - state.rover.battery.resistance * state.rover.battery.current;
    
    % Calculate the torque and thrust, assume RPM is last step value
    for i = 1:numel(state.rover.motors)
        motor = state.rover.motors(i);
    
        % Calculate the throttle
        throttle = abs((pwm_in(motor.channel) - 1500)) / 800;
    
        % effective voltage
        voltage = throttle * state.rover.battery.dropped_voltage;
    
        % Take the RPM from the last step to calculate the new
        % torque and current
        Kt = 1/(motor.electrical.kv * ( (2*pi)/60) );
    
        % rpm equation rearranged for current
        current = ((motor.electrical.kv * voltage) - motor.rpm) / ((motor.electrical.resistance + motor.esc.resistance) * motor.electrical.kv);
        torque = current * Kt;
    
        prop_drag = motor.prop.PConst * state.environment.density * (motor.rpm/60)^2 * motor.prop.diameter^5;
    
        w = motor.rpm * ((2*pi)/60); % convert to rad/sec
    
        w1 = w + ((torque-prop_drag) / motor.prop.inertia) * state.delta_t;
    
        rps = w1 * (1/(2*pi));
    
        % can never have negative rps
%         rps = max(rps,0);
    
        % Calculate the thrust (with fudge factor!)
        thrust = 200.2 * motor.prop.TConst * state.environment.density * rps^2 * motor.prop.diameter^4;
        thrust = thrust*sign((pwm_in(motor.channel) - 1500));
    
        % calculate resulting moments
%         moment_roll = thrust * motor.location(1);
%         moment_pitch = thrust * motor.location(2);
%         moment_yaw = -torque * motor.direction;
        if i < 3
            moment_yaw = -thrust*state.rover.motor_radius; % *sign(cosd(motor.thrustdir));
        else
            moment_yaw = thrust*state.rover.motor_radius; % *sign(cosd(motor.thrustdir));
        end
    
        % Update main structure
        state.rover.motors(i).torque = torque;
        state.rover.motors(i).current = current;
        state.rover.motors(i).rpm = rps * 60;
        state.rover.motors(i).thrust = thrust;
        state.rover.motors(i).moment_roll = 0;
        state.rover.motors(i).moment_pitch = 0;
%         state.rover.motors(i).moment_roll = moment_roll;
%         state.rover.motors(i).moment_pitch = moment_pitch;
        state.rover.motors(i).moment_yaw = moment_yaw;
    end
    
%     drag = 100*sign(state.bf_velo) .* state.rover.cd .* state.rover.cd_ref_area .* 0.5 .* state.environment.density .* state.bf_velo.^2;
%     current_drag = -[u;v;0]*250; % N, 
%     current_u = 1;%2.5;
%     current_v = 0;
%     current_drag = -[current_v;current_u;0]*250;
%     current_drag = -[500;0;0]; % N, 
%     current_drag = -[0;500;0]; % E, 
%     apparent_velo = state.bf_velo - [state.current_v;state.current_u;0];
%     velo_bf = inv(state.dcm) * [state.current_v;state.current_u;0];
    velo_bf = state.dcm \ [state.current_v;state.current_u;0];
    apparent_velo = state.bf_velo - velo_bf;

    drag = 100*sign(apparent_velo) .* state.rover.cd .* state.rover.cd_ref_area .* 0.5 .* state.environment.density .* apparent_velo.^2;
%     drag = drag + current_drag;
    
    
    % Calculate the forces about the CG (N,E,D) (body frame)
%     force = [0;0;-sum([state.rover.motors.thrust])] - drag;
    fx = zeros(1,numel(state.rover.motors));
    fy = zeros(1,numel(state.rover.motors));
    for i = 1:numel(state.rover.motors)
        fx(i) = state.rover.motors(i).thrust.*cosd(state.rover.motors(i).thrustdir);
        fy(i) = state.rover.motors(i).thrust.*sind(state.rover.motors(i).thrustdir);
    end
    force = [sum(fy);sum(fx);0] - drag;

%     TT = 60;
%     if state.totaltime > TT
% %         disp('pushing')
%         force = force + [50;0;0];
%         if state.totaltime > TT + 10 % turn off push
% %             disp('stopped pushing')
%             state.totaltime = 0;
%         end
%     end
    
    % estimate rotational drag
    rotational_drag = 2000.2 * sign(state.gyro) .* state.gyro.^2; % estimated to give a reasonable max rotation rate
    
    % Update attitude, moments to rotational acceleration to rotational velocity to attitude
    moments = [-sum([state.rover.motors.moment_roll]);...
        sum([state.rover.motors.moment_pitch]);...
        sum([state.rover.motors.moment_yaw])] - rotational_drag;
    
    state = update_dynamics(state,force,moments);

%     state.attitude = [10;10;50]*pi/180;

end

% integrate the acceleration resulting from the forces and moments to get the
% new state
function state = update_dynamics(state,force,moments)
%     fudge = 1;
    rot_accel = (moments' / state.rover.inertia)';
%     rot_drag = -fudge*(state.gyro.^2);
%     rot_accel = rot_accel + rot_drag;
%     rot_accel = [0;0;0];
    
    state.gyro = state.gyro + rot_accel * state.delta_t;
    
    % Constrain to 2000 deg per second, this is what typical sensors max out at
    state.gyro = max(state.gyro,deg2rad(-2000));
    state.gyro = min(state.gyro,deg2rad(2000));
    
    % update the dcm and attitude
    [state.dcm, state.attitude] = rotate_dcm(state.dcm,state.gyro * state.delta_t);
%     state.dcm
%     state.attitude

    
    % body frame accelerations
    state.accel = force / state.rover.mass;
%     state.accel
    
    % earth frame accelerations (NED)
    accel_ef = state.dcm * state.accel;
%     accel_ef(3) = accel_ef(3) + state.gravity_mss;
    accel_ef(3) = 0;
   
%     current_u = 1;%2.5;
%     current_v = 0;
%     apparent_velo = state.velocity - [state.current_v;state.current_u;0];
%     accel_ef0 = accel_ef;
%     accel_ef = accel_ef - apparent_velo;
%     [accel_ef0 state.velocity  accel_ef]
    
    % if we're on the ground, then our vertical acceleration is limited
    % to zero. This effectively adds the force of the ground on the aircraft
    if state.position(3) >= 0 && accel_ef(3) > 0
        accel_ef(3) = 0;
    end
    
    % work out acceleration as seen by the accelerometers. It sees the kinematic
    % acceleration (ie. real movement), plus gravity
    state.accel = state.dcm' * (accel_ef + [0; 0; -state.gravity_mss]);
    
    state.velocity = state.velocity + accel_ef * state.delta_t;
    state.position = state.position + state.velocity * state.delta_t;
%     [accel_ef state.velocity state.position]

    state.totaltime = state.totaltime + state.delta_t;
%     TT = 60;
%     if state.totaltime > TT
%         
% %         state.velocity = [1 0 0]';
%         state.totaltime = 0;
%     end
    
    % make sure we can't go underground (NED so underground is positive)
%     if state.position(3) >= 0
%         state.position(3) = 0;
%         state.velocity = [0;0;0];
%         state.gyro = [0;0;0];
%     end
    
    % calculate the body frame velocity for drag calculation
    state.bf_velo = state.dcm' * state.velocity;

end

function [dcm, euler] = rotate_dcm(dcm, ang)
    
    % rotate
    delta = [dcm(1,2) * ang(3) - dcm(1,3) * ang(2),         dcm(1,3) * ang(1) - dcm(1,1) * ang(3),      dcm(1,1) * ang(2) - dcm(1,2) * ang(1);
        dcm(2,2) * ang(3) - dcm(2,3) * ang(2),         dcm(2,3) * ang(1) - dcm(2,1) * ang(3),      dcm(2,1) * ang(2) - dcm(2,2) * ang(1);
        dcm(3,2) * ang(3) - dcm(3,3) * ang(2),         dcm(3,3) * ang(1) - dcm(3,1) * ang(3),      dcm(3,1) * ang(2) - dcm(3,2) * ang(1)];
    
    dcm = dcm + delta;
    
    % normalise
    a = dcm(1,:);
    b = dcm(2,:);
    error = a * b';
    t0 = a - (b *(0.5 * error));
    t1 = b - (a *(0.5 * error));
    t2 = cross(t0,t1);
    dcm(1,:) = t0 * (1/norm(t0));
    dcm(2,:) = t1 * (1/norm(t1));
    dcm(3,:) = t2 * (1/norm(t2));
    
    % calculate euler angles
    euler = [atan2(dcm(3,2),dcm(3,3)); -asin(dcm(3,1)); atan2(dcm(2,1),dcm(1,1))];

end

